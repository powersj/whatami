{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"whatsthis Am I on a cloud, in a container, virtualized, or plain bare metal? Overview whatsthis is a Go-based CLI and library to determine where a system is running and what makes up the system. To determine where a system is running, whatsthis will attempt to make a best-effort guess based on a variety of heuristics as to what container, virtualization, or cloud the system is running on. This is similar to an all-in-one collection of the systemd-detect-virt , virt-what , and cloud-id commands. To summarize the system components, whatsthis will scan the filesystem for known files in /sys , /proc , or other directories. This data is then used to create a short summarize of the system in place of running several other commands (e.g. lsblk , ip , dmesg , dmidecode ) Install For complete details on how to install from binary, source, or from go, check out the install page for more information. This page also details the support for architectures and operating systems. See the latest release page for the available binary downloads. CLI To get a full summary of the system run whatsthis and the output will show a breakdown module name by module name: $ whatsthis --- cloud: not detected virt: not detected container: not detected --- distro: Ubuntu 20.10 (amd64) kernel: 5.8.0-33-generic --- board: ASUSTeK COMPUTER INC. TUF GAMING X570-PRO (WI-FI) bios: American Megatrends Inc. BIOS 3001 (12/04/2020) cpu: AMD Ryzen 9 5950X 16-Core Processor with 16 cores (32 threads) on 1 socket memory: 31.3G network: adapters: - enp6s0 24:4b:fe:9a:a4:fa 1000 mtu 9000 (igc) virtual: - virbr0-nic 52:54:00:6d:53:f1 mtu 1500 bridges: - docker0 02:42:96:01:ec:70 mtu 1500 - virbr0 52:54:00:6d:53:f1 mtu 1500 storage: nvme0n1 931.5G: - nvme0n1p1 512M EFI System Partition - nvme0n1p2 931G nvme1n1 1.9T: - nvme1n1p4 498M - nvme1n1p2 16M Microsoft reserved partition - nvme1n1p3 1.9T Basic data partition - nvme1n1p1 100M EFI system partition To run only one particular module, run with only that module name: $ whatsthis cpu cpu: AMD Ryzen 9 5950X 16-Core Processor with 16 cores (32 threads) on 1 socket Finally, to get the output in JSON add the --json flag: $ wha tst his cpu -- jso n { \"model\" : \"AMD Ryzen 9 5950X 16-Core Processor\" , \"numCore\" : 16 , \"numThread\" : 32 , \"numSocket\" : 1 } See whatsthis help for a full list of modules and more information on options. API whatsthis offers several structs and functions to help determine the cloud, container, virtualization, and the underlying hardware of a system. Users can take advantage of these in their own code: package main import ( \"fmt\" \"github.com/powersj/whatsthis\" ) func main () { cloud , err := whatsthis . Cloud () if err != nil { fmt . Printf ( \"Error getting cloud info: %v\" , err ) } if cloud . Detected { fmt . Printf ( cloud . Name ) } } Support If you find a bug, have a question, or ideas for improvements please file an issue on GitHub.","title":"Overview"},{"location":"#whatsthis","text":"Am I on a cloud, in a container, virtualized, or plain bare metal?","title":"whatsthis"},{"location":"#overview","text":"whatsthis is a Go-based CLI and library to determine where a system is running and what makes up the system. To determine where a system is running, whatsthis will attempt to make a best-effort guess based on a variety of heuristics as to what container, virtualization, or cloud the system is running on. This is similar to an all-in-one collection of the systemd-detect-virt , virt-what , and cloud-id commands. To summarize the system components, whatsthis will scan the filesystem for known files in /sys , /proc , or other directories. This data is then used to create a short summarize of the system in place of running several other commands (e.g. lsblk , ip , dmesg , dmidecode )","title":"Overview"},{"location":"#install","text":"For complete details on how to install from binary, source, or from go, check out the install page for more information. This page also details the support for architectures and operating systems. See the latest release page for the available binary downloads.","title":"Install"},{"location":"#cli","text":"To get a full summary of the system run whatsthis and the output will show a breakdown module name by module name: $ whatsthis --- cloud: not detected virt: not detected container: not detected --- distro: Ubuntu 20.10 (amd64) kernel: 5.8.0-33-generic --- board: ASUSTeK COMPUTER INC. TUF GAMING X570-PRO (WI-FI) bios: American Megatrends Inc. BIOS 3001 (12/04/2020) cpu: AMD Ryzen 9 5950X 16-Core Processor with 16 cores (32 threads) on 1 socket memory: 31.3G network: adapters: - enp6s0 24:4b:fe:9a:a4:fa 1000 mtu 9000 (igc) virtual: - virbr0-nic 52:54:00:6d:53:f1 mtu 1500 bridges: - docker0 02:42:96:01:ec:70 mtu 1500 - virbr0 52:54:00:6d:53:f1 mtu 1500 storage: nvme0n1 931.5G: - nvme0n1p1 512M EFI System Partition - nvme0n1p2 931G nvme1n1 1.9T: - nvme1n1p4 498M - nvme1n1p2 16M Microsoft reserved partition - nvme1n1p3 1.9T Basic data partition - nvme1n1p1 100M EFI system partition To run only one particular module, run with only that module name: $ whatsthis cpu cpu: AMD Ryzen 9 5950X 16-Core Processor with 16 cores (32 threads) on 1 socket Finally, to get the output in JSON add the --json flag: $ wha tst his cpu -- jso n { \"model\" : \"AMD Ryzen 9 5950X 16-Core Processor\" , \"numCore\" : 16 , \"numThread\" : 32 , \"numSocket\" : 1 } See whatsthis help for a full list of modules and more information on options.","title":"CLI"},{"location":"#api","text":"whatsthis offers several structs and functions to help determine the cloud, container, virtualization, and the underlying hardware of a system. Users can take advantage of these in their own code: package main import ( \"fmt\" \"github.com/powersj/whatsthis\" ) func main () { cloud , err := whatsthis . Cloud () if err != nil { fmt . Printf ( \"Error getting cloud info: %v\" , err ) } if cloud . Detected { fmt . Printf ( cloud . Name ) } }","title":"API"},{"location":"#support","text":"If you find a bug, have a question, or ideas for improvements please file an issue on GitHub.","title":"Support"},{"location":"cli/","text":"CLI To get a full summary of the system run whatsthis and the output will show a breakdown probe by probe: $ whatsthis --- cloud: not detected virt: not detected container: not detected --- distro: Ubuntu 20.10 (amd64) kernel: 5.8.0-33-generic --- board: ASUSTeK COMPUTER INC. TUF GAMING X570-PRO (WI-FI) bios: American Megatrends Inc. BIOS 3001 (12/04/2020) cpu: AMD Ryzen 9 5950X 16-Core Processor with 16 cores (32 threads) on 1 socket memory: 31.3G network: - adapters: - enp6s0 24:4b:fe:9a:a4:fa 1000 mtu 9000 (igc) - virtual: - virbr0-nic 52:54:00:6d:53:f1 mtu 1500 - bridges: - docker0 02:42:96:01:ec:70 mtu 1500 - virbr0 52:54:00:6d:53:f1 mtu 1500 storage: - nvme0n1 931.5G - nvme0n1p1 512M EFI System Partition - nvme0n1p2 931G - nvme1n1 1.9T - nvme1n1p4 498M - nvme1n1p2 16M Microsoft reserved partition - nvme1n1p3 1.9T Basic data partition - nvme1n1p1 100M EFI system partition Subcommands To run only one particular probe, run with only that probe name: $ whatsthis cpu cpu: AMD Ryzen 9 5950X 16-Core Processor with 16 cores (32 threads) on 1 socket There are subcommands for the following probes: cloud container cpu distro memory network platform storage virt JSON output All commands can take the --json flag to produce JSON output: $ wha tst his cpu -- jso n { \"model\" : \"AMD Ryzen 9 5950X 16-Core Processor\" , \"numCore\" : 16 , \"numThread\" : 32 , \"numSocket\" : 1 }","title":"CLI"},{"location":"cli/#cli","text":"To get a full summary of the system run whatsthis and the output will show a breakdown probe by probe: $ whatsthis --- cloud: not detected virt: not detected container: not detected --- distro: Ubuntu 20.10 (amd64) kernel: 5.8.0-33-generic --- board: ASUSTeK COMPUTER INC. TUF GAMING X570-PRO (WI-FI) bios: American Megatrends Inc. BIOS 3001 (12/04/2020) cpu: AMD Ryzen 9 5950X 16-Core Processor with 16 cores (32 threads) on 1 socket memory: 31.3G network: - adapters: - enp6s0 24:4b:fe:9a:a4:fa 1000 mtu 9000 (igc) - virtual: - virbr0-nic 52:54:00:6d:53:f1 mtu 1500 - bridges: - docker0 02:42:96:01:ec:70 mtu 1500 - virbr0 52:54:00:6d:53:f1 mtu 1500 storage: - nvme0n1 931.5G - nvme0n1p1 512M EFI System Partition - nvme0n1p2 931G - nvme1n1 1.9T - nvme1n1p4 498M - nvme1n1p2 16M Microsoft reserved partition - nvme1n1p3 1.9T Basic data partition - nvme1n1p1 100M EFI system partition","title":"CLI"},{"location":"cli/#subcommands","text":"To run only one particular probe, run with only that probe name: $ whatsthis cpu cpu: AMD Ryzen 9 5950X 16-Core Processor with 16 cores (32 threads) on 1 socket There are subcommands for the following probes: cloud container cpu distro memory network platform storage virt","title":"Subcommands"},{"location":"cli/#json-output","text":"All commands can take the --json flag to produce JSON output: $ wha tst his cpu -- jso n { \"model\" : \"AMD Ryzen 9 5950X 16-Core Processor\" , \"numCore\" : 16 , \"numThread\" : 32 , \"numSocket\" : 1 }","title":"JSON output"},{"location":"install/","text":"Install Below outlines the various ways to obtain and install whatsthis. From binary Download the latest release of whatsthis for your platform and extract the tarball: wget whatsthis_<version>_<os>_<arch>.tar.gz tar zxvf whatsthis_<version>_<os>_<arch>.tar.gz The tarball will extract the readme, license, and the pre-compiled binary. From source To build and install whatsthis directly from source run: git clone https://github.com/powersj/whatsthis cd whatsthis make The default make command will run go build and produce a whatsthis binary in the root directory. From go To download using the go get command run: go get github.com/powersj/whatsthis The executable object file location will exist at ${GOPATH}/bin/whatsthis Architecture support Releases include binaries for x86-64 (amd64) as well as some initial support for ARMv8 (arm64). The ARMv8 architecture does not have the same cpuid capabilities in place as x86-64 does. As such the virtualization detection on ARMv8 is not functional. Architecture Support x86-64 yes ARMv8 limited ARMv6 none ppc64le none s390x none x86 none Operating system support whatsthis was developed with Linux based OSes in mind. Operating System Support Linux yes Darwin none FreeBSD none Windows none FreeBSDs does not mount /proc by default and /sys is replaced by sysctl . whatsthis could learn how to use sysctl down the road. This could also help enable Darwin support. Additionally, Windows support could be learned by looking at the Windows Management Instrumentation (WMI).","title":"Install"},{"location":"install/#install","text":"Below outlines the various ways to obtain and install whatsthis.","title":"Install"},{"location":"install/#from-binary","text":"Download the latest release of whatsthis for your platform and extract the tarball: wget whatsthis_<version>_<os>_<arch>.tar.gz tar zxvf whatsthis_<version>_<os>_<arch>.tar.gz The tarball will extract the readme, license, and the pre-compiled binary.","title":"From binary"},{"location":"install/#from-source","text":"To build and install whatsthis directly from source run: git clone https://github.com/powersj/whatsthis cd whatsthis make The default make command will run go build and produce a whatsthis binary in the root directory.","title":"From source"},{"location":"install/#from-go","text":"To download using the go get command run: go get github.com/powersj/whatsthis The executable object file location will exist at ${GOPATH}/bin/whatsthis","title":"From go"},{"location":"install/#architecture-support","text":"Releases include binaries for x86-64 (amd64) as well as some initial support for ARMv8 (arm64). The ARMv8 architecture does not have the same cpuid capabilities in place as x86-64 does. As such the virtualization detection on ARMv8 is not functional. Architecture Support x86-64 yes ARMv8 limited ARMv6 none ppc64le none s390x none x86 none","title":"Architecture support"},{"location":"install/#operating-system-support","text":"whatsthis was developed with Linux based OSes in mind. Operating System Support Linux yes Darwin none FreeBSD none Windows none FreeBSDs does not mount /proc by default and /sys is replaced by sysctl . whatsthis could learn how to use sysctl down the road. This could also help enable Darwin support. Additionally, Windows support could be learned by looking at the Windows Management Instrumentation (WMI).","title":"Operating system support"},{"location":"contributing/documentation/","text":"Documentation The documentation is built with MkDocs and the Material for MkDocs theme and is written in Markdown. Building To build the documentation site, first setup a Python virtual environment and install the mkdocs-material package, which will pull in all other dependencies: virtualenv .venv . .venv/bin/activate pip install mkdocs-material To build the docs, use the makefile target: make docs Launch a web server to pull up the docs and then point a browser at http://0.0.0.0:8000/ to view the site: python3 -m http.server --directory site/","title":"Docs"},{"location":"contributing/documentation/#documentation","text":"The documentation is built with MkDocs and the Material for MkDocs theme and is written in Markdown.","title":"Documentation"},{"location":"contributing/documentation/#building","text":"To build the documentation site, first setup a Python virtual environment and install the mkdocs-material package, which will pull in all other dependencies: virtualenv .venv . .venv/bin/activate pip install mkdocs-material To build the docs, use the makefile target: make docs Launch a web server to pull up the docs and then point a browser at http://0.0.0.0:8000/ to view the site: python3 -m http.server --directory site/","title":"Building"},{"location":"contributing/overview/","text":"Contributing How to contribute I want your help. No really, I do. There might be a little voice inside that tells you you're not ready; that you need to do one more tutorial, or learn another framework, or write a few more blog posts before you can help me with this project. I assure you, that's not the case. This project has some clear Contribution Guidelines and expectations that you can read below. The contribution guidelines outline the process that you will need to follow to get a patch merged. By making expectations and process explicit, I hope it will make it easier for you to contribute. And you don't just have to write code. You can help out by writing documentation, tests, or even by giving feedback about this work. (And yes, that includes giving feedback about the contribution guidelines.) Thank you for contributing! (The above is from Adrienne Lowe ) Getting started Fork the repository on GitHub Read the index.md for getting started and look through the documentation for any other basic help. Play with the project on a variety of systems and environments, submit bugs, and submit pull requests! Developing a merge request Find an issue or create your own. Create a feature or bug fix branch in your fork of the repo. Write your feature or fix your bug. Make commits of logical units. If needed, update the documentation in either the README or docs folder. Ensure the project passes the lint tests, builds, and tests pass. Push and submit your pull request! Code changes The project has a basic CI setup already, which will run a lint, build, build the docs, and tests. These need to pass and I am more than willing to help you work through any issues you come across. This includes disabling or changing the config on the linters. These CI steps are very easy to run using the makefile via: make lint make build make docs make test Documentation changes If you are working on the documentation, ensure it continues to build using the steps outlined on the documentation page. Commit message This is the rough convention I follow for commit messages: topic: <short title for what changed> <BLANK LINE> <why this change was made and what changed> <BLANK LINE> Fixes #1 The first line is the subject and should be no longer than 70 characters, the second line is always blank, and other lines should be wrapped at 80 characters. Acceptance These things will make a PR more likely to be accepted: a well-described requirement tests for new code tests for old code! new code and tests follow the conventions in old code and tests a good commit message In general, I will merge a PR once I reviewed and approved it. Trivial changes (e.g., corrections to spelling) will get waved through. For substantial changes, you might get asked to resubmit the PR or divide the changes into more than one PR.","title":"Overview"},{"location":"contributing/overview/#contributing","text":"","title":"Contributing"},{"location":"contributing/overview/#how-to-contribute","text":"I want your help. No really, I do. There might be a little voice inside that tells you you're not ready; that you need to do one more tutorial, or learn another framework, or write a few more blog posts before you can help me with this project. I assure you, that's not the case. This project has some clear Contribution Guidelines and expectations that you can read below. The contribution guidelines outline the process that you will need to follow to get a patch merged. By making expectations and process explicit, I hope it will make it easier for you to contribute. And you don't just have to write code. You can help out by writing documentation, tests, or even by giving feedback about this work. (And yes, that includes giving feedback about the contribution guidelines.) Thank you for contributing! (The above is from Adrienne Lowe )","title":"How to contribute"},{"location":"contributing/overview/#getting-started","text":"Fork the repository on GitHub Read the index.md for getting started and look through the documentation for any other basic help. Play with the project on a variety of systems and environments, submit bugs, and submit pull requests!","title":"Getting started"},{"location":"contributing/overview/#developing-a-merge-request","text":"Find an issue or create your own. Create a feature or bug fix branch in your fork of the repo. Write your feature or fix your bug. Make commits of logical units. If needed, update the documentation in either the README or docs folder. Ensure the project passes the lint tests, builds, and tests pass. Push and submit your pull request!","title":"Developing a merge request"},{"location":"contributing/overview/#code-changes","text":"The project has a basic CI setup already, which will run a lint, build, build the docs, and tests. These need to pass and I am more than willing to help you work through any issues you come across. This includes disabling or changing the config on the linters. These CI steps are very easy to run using the makefile via: make lint make build make docs make test","title":"Code changes"},{"location":"contributing/overview/#documentation-changes","text":"If you are working on the documentation, ensure it continues to build using the steps outlined on the documentation page.","title":"Documentation changes"},{"location":"contributing/overview/#commit-message","text":"This is the rough convention I follow for commit messages: topic: <short title for what changed> <BLANK LINE> <why this change was made and what changed> <BLANK LINE> Fixes #1 The first line is the subject and should be no longer than 70 characters, the second line is always blank, and other lines should be wrapped at 80 characters.","title":"Commit message"},{"location":"contributing/overview/#acceptance","text":"These things will make a PR more likely to be accepted: a well-described requirement tests for new code tests for old code! new code and tests follow the conventions in old code and tests a good commit message In general, I will merge a PR once I reviewed and approved it. Trivial changes (e.g., corrections to spelling) will get waved through. For substantial changes, you might get asked to resubmit the PR or divide the changes into more than one PR.","title":"Acceptance"},{"location":"contributing/roadmap/","text":"Roadmap This is a collection of future ideas for the project. Next Examples: include how to use this to query specific subsystems inside a go-lang project Greater debug output Next + 1 Greater arm64 support for virtualization PCI IDs for network and storage devices whatsthis-collect: enable basic functionality to start capturing required files Next + 2 Custom source directory *BSD support","title":"Roadmap"},{"location":"contributing/roadmap/#roadmap","text":"This is a collection of future ideas for the project.","title":"Roadmap"},{"location":"contributing/roadmap/#next","text":"Examples: include how to use this to query specific subsystems inside a go-lang project Greater debug output","title":"Next"},{"location":"contributing/roadmap/#next-1","text":"Greater arm64 support for virtualization PCI IDs for network and storage devices whatsthis-collect: enable basic functionality to start capturing required files","title":"Next + 1"},{"location":"contributing/roadmap/#next-2","text":"Custom source directory *BSD support","title":"Next + 2"},{"location":"contributing/versioning/","text":"Versioning The project follows Sematic Versioning . Release a new version The current under-development release version is kept in app/whatsthis/cmd/root.go : const ( version = \"v1.2.0\" ) To release a new version create and push a new tag, then run the goreleaser: git tag -a v1.2.0 -m \"Summary of release\" git push origin v1.2.0 make release This will create the corresponding GitHub Releases page and upload the artifacts to it. Then increment the version in app/whatsthis/cmd/root.go and push that change to open the next version: git commit -am \"Open release v1.3.0\" git push","title":"Versioning"},{"location":"contributing/versioning/#versioning","text":"The project follows Sematic Versioning .","title":"Versioning"},{"location":"contributing/versioning/#release-a-new-version","text":"The current under-development release version is kept in app/whatsthis/cmd/root.go : const ( version = \"v1.2.0\" ) To release a new version create and push a new tag, then run the goreleaser: git tag -a v1.2.0 -m \"Summary of release\" git push origin v1.2.0 make release This will create the corresponding GitHub Releases page and upload the artifacts to it. Then increment the version in app/whatsthis/cmd/root.go and push that change to open the next version: git commit -am \"Open release v1.3.0\" git push","title":"Release a new version"},{"location":"probes/clouds/","text":"Clouds Detection whatsthis attempts to identify if the system is running on a cloud based on various heuristics. Supported Amazon Web Services Amazon Web Services (AWS) has three types of instance platforms: Bare metal Nitro (KVM) HVM (Xen) Bare metal and Nitro (KVM) based instances will report \"Amazon EC2\" as the system vendor. The older Xen based systems (e.g t2) will report Xen. To further identify these systems the Hypervisor UUID will start with \"ec2\". These heuristics come from Amazon's website Alibaba Cloud Alibaba instances report the product name as \"Alibaba Cloud ECS\". CloudSigma CloudSigma instances report the product name as \"CloudSigma\". CloudStack CloudStack instances reported product name will start with \"CloudStack\". Digital Ocean Digital Ocean instances report the system vendor as \"DigitalOcean\". Exoscale Exoscale instances report the product name as \"Exoscale\". Google Cloud Platform Google Cloud Platform instances report the product name as \"Google Compute Engine\". Hetzner Hetzner instances report the system vendor as \"Hetzner\". Microsoft Azure Microsoft Azure instances report the chassis asset tag as the hard-coded value of \"7783-7084-3265-9085-8269-3286-77\". OpenStack OpenStack instances report system vendor as \"OpenStack Foundation\". Oracle Cloud Oracle cloud report the chassis asset tag as \"OracleCloud.com\". SmartOS SmartOS reports the product name start with \"SmartDC\". Other Other clouds that could be added at a future date include: IBM Cloud","title":"Clouds"},{"location":"probes/clouds/#clouds","text":"","title":"Clouds"},{"location":"probes/clouds/#detection","text":"whatsthis attempts to identify if the system is running on a cloud based on various heuristics.","title":"Detection"},{"location":"probes/clouds/#supported","text":"","title":"Supported"},{"location":"probes/clouds/#amazon-web-services","text":"Amazon Web Services (AWS) has three types of instance platforms: Bare metal Nitro (KVM) HVM (Xen) Bare metal and Nitro (KVM) based instances will report \"Amazon EC2\" as the system vendor. The older Xen based systems (e.g t2) will report Xen. To further identify these systems the Hypervisor UUID will start with \"ec2\". These heuristics come from Amazon's website","title":"Amazon Web Services"},{"location":"probes/clouds/#alibaba-cloud","text":"Alibaba instances report the product name as \"Alibaba Cloud ECS\".","title":"Alibaba Cloud"},{"location":"probes/clouds/#cloudsigma","text":"CloudSigma instances report the product name as \"CloudSigma\".","title":"CloudSigma"},{"location":"probes/clouds/#cloudstack","text":"CloudStack instances reported product name will start with \"CloudStack\".","title":"CloudStack"},{"location":"probes/clouds/#digital-ocean","text":"Digital Ocean instances report the system vendor as \"DigitalOcean\".","title":"Digital Ocean"},{"location":"probes/clouds/#exoscale","text":"Exoscale instances report the product name as \"Exoscale\".","title":"Exoscale"},{"location":"probes/clouds/#google-cloud-platform","text":"Google Cloud Platform instances report the product name as \"Google Compute Engine\".","title":"Google Cloud Platform"},{"location":"probes/clouds/#hetzner","text":"Hetzner instances report the system vendor as \"Hetzner\".","title":"Hetzner"},{"location":"probes/clouds/#microsoft-azure","text":"Microsoft Azure instances report the chassis asset tag as the hard-coded value of \"7783-7084-3265-9085-8269-3286-77\".","title":"Microsoft Azure"},{"location":"probes/clouds/#openstack","text":"OpenStack instances report system vendor as \"OpenStack Foundation\".","title":"OpenStack"},{"location":"probes/clouds/#oracle-cloud","text":"Oracle cloud report the chassis asset tag as \"OracleCloud.com\".","title":"Oracle Cloud"},{"location":"probes/clouds/#smartos","text":"SmartOS reports the product name start with \"SmartDC\".","title":"SmartOS"},{"location":"probes/clouds/#other","text":"Other clouds that could be added at a future date include: IBM Cloud","title":"Other"},{"location":"probes/containers/","text":"Containers Detection whatsthis attempts to identify if the system is running in a container based on a variety of heuristic. Supported docker First look for the /run/.dockerenv file to identify a Docker container. Then look for \"docker\" inside /proc/cgroups . lxc Looks for the string \"container=\" in /proc/environ . podman Per a GitHub issue on the podman project page, there is a guarantee that container environment variable will be set to \"podman\". The environment variable could be overridden by a user or image creator. As such, this looks for the /run/.containerenv file as well. wsl Per a GitHub issue on the WSL project page, checking for \"microsoft\" in either of these two files: /proc/sys/kernel/osrelease /proc/version Other For the initial development of the app, platforms were limited to those that could easily be tested. The are some additional container run-times that could be added at a later date: bottlerocket rkt : however, per GitHub page no longer under development openvz : the commercial version, Virtuozzo is available, but otherwise development appears to have ended","title":"Containers"},{"location":"probes/containers/#containers","text":"","title":"Containers"},{"location":"probes/containers/#detection","text":"whatsthis attempts to identify if the system is running in a container based on a variety of heuristic.","title":"Detection"},{"location":"probes/containers/#supported","text":"","title":"Supported"},{"location":"probes/containers/#docker","text":"First look for the /run/.dockerenv file to identify a Docker container. Then look for \"docker\" inside /proc/cgroups .","title":"docker"},{"location":"probes/containers/#lxc","text":"Looks for the string \"container=\" in /proc/environ .","title":"lxc"},{"location":"probes/containers/#podman","text":"Per a GitHub issue on the podman project page, there is a guarantee that container environment variable will be set to \"podman\". The environment variable could be overridden by a user or image creator. As such, this looks for the /run/.containerenv file as well.","title":"podman"},{"location":"probes/containers/#wsl","text":"Per a GitHub issue on the WSL project page, checking for \"microsoft\" in either of these two files: /proc/sys/kernel/osrelease /proc/version","title":"wsl"},{"location":"probes/containers/#other","text":"For the initial development of the app, platforms were limited to those that could easily be tested. The are some additional container run-times that could be added at a later date: bottlerocket rkt : however, per GitHub page no longer under development openvz : the commercial version, Virtuozzo is available, but otherwise development appears to have ended","title":"Other"},{"location":"probes/virtualization/","text":"Virtualization Detection whatsthis attempts to identify the system's virtualization platforms based on the result of the CPU identification instruction known as cpuid . The instruction was created to provide a mechanism for programmers to obtain the system's CPU model. Virtualization providers will set this string to provide a mechanism to determine what virtualization platform a system is running on. Bug As cpuid is only available on x86-64, virtualization support in aarch64 is currently non-existent. When running on aarch64, the function will always return an empty string and therefore never detect any virtualization platform correctly. Supported Below is a table of the currently known virtualization platforms and their corresponding advertised vendor ID found from cpuid: Platform Vendor ID bhyve bhyve bhyve hyper-v Microsoft Hv kvm KVMKVMKVM parallels lrpepyh vr qemu TCGTCGTCGTCG vmware VMwareVMware xen XenVMMXenVMM Note Using cpuid on these platforms provides a good first heuristic when attempting to determine the platform. However, there are cases where these platforms have additional product offerings and using the cpuid alone is not enough. Please feel free to file an issue if you come across one of these scenarios. Other Other virtualization detection software like virt-what or imvirt have detection for other additional platforms. For the initial development of the app, platforms were limited to those that could easily be tested. The are some additional virtualization platforms that could be added at a later date: acrn bochs qnx lkvm uml virtual box","title":"Virtualization"},{"location":"probes/virtualization/#virtualization","text":"","title":"Virtualization"},{"location":"probes/virtualization/#detection","text":"whatsthis attempts to identify the system's virtualization platforms based on the result of the CPU identification instruction known as cpuid . The instruction was created to provide a mechanism for programmers to obtain the system's CPU model. Virtualization providers will set this string to provide a mechanism to determine what virtualization platform a system is running on. Bug As cpuid is only available on x86-64, virtualization support in aarch64 is currently non-existent. When running on aarch64, the function will always return an empty string and therefore never detect any virtualization platform correctly.","title":"Detection"},{"location":"probes/virtualization/#supported","text":"Below is a table of the currently known virtualization platforms and their corresponding advertised vendor ID found from cpuid: Platform Vendor ID bhyve bhyve bhyve hyper-v Microsoft Hv kvm KVMKVMKVM parallels lrpepyh vr qemu TCGTCGTCGTCG vmware VMwareVMware xen XenVMMXenVMM Note Using cpuid on these platforms provides a good first heuristic when attempting to determine the platform. However, there are cases where these platforms have additional product offerings and using the cpuid alone is not enough. Please feel free to file an issue if you come across one of these scenarios.","title":"Supported"},{"location":"probes/virtualization/#other","text":"Other virtualization detection software like virt-what or imvirt have detection for other additional platforms. For the initial development of the app, platforms were limited to those that could easily be tested. The are some additional virtualization platforms that could be added at a later date: acrn bochs qnx lkvm uml virtual box","title":"Other"},{"location":"testing/containers/","text":"Containers Below are the test cases used to confirm container identification. These assume a user is running on Ubuntu 20.04 LTS or later. Essentially, each test case is to launch a container, copy the whatsthis binary over, and run it. Finally, confirm the container is correctly reported. Docker snap install docker docker run --detach --tty --name test ubuntu docker cp whatsthis test:/ docker exec -it test /whatsthis docker container rm --force test LXC snap install lxc lxc launch ubuntu-daily:focal test lxc file push whatsthis test/root/whatsthis lxc exec test /root/whatsthis lxc delete --force test Podman snap install podman podman run --detach --tty --name test ubuntu podman cp whatsthis test:/ podman exec -it test /whatsthis podman container rm --force test WSL Enable WSL Open a PowerShell console as Administrator and run the following to enable WSL and WSL 2: dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart There is an additional kernel update package required for download here . Once installed, reboot the system to begin using WSL. For more details see these official instructions here . WSL Version To set WSL 2 as the default version run the following as Administrator in a PowerShell console: wsl --set-default-version 2 It can be helpful to switch between WSL 1 and WSL 2 during testing. Users can list all distributions and change the version of any running distribution by running. wsl --list --all wsl --set-version <distro> [ 2 | 1 ] Testing Finally, to test the binary on a WSL distribution, copy it from your local filesystem by accessing it from /mnt/c : cp /mnt/c/Users/<username>/Documents... whatthis ./whatsthis","title":"Containers"},{"location":"testing/containers/#containers","text":"Below are the test cases used to confirm container identification. These assume a user is running on Ubuntu 20.04 LTS or later. Essentially, each test case is to launch a container, copy the whatsthis binary over, and run it. Finally, confirm the container is correctly reported.","title":"Containers"},{"location":"testing/containers/#docker","text":"snap install docker docker run --detach --tty --name test ubuntu docker cp whatsthis test:/ docker exec -it test /whatsthis docker container rm --force test","title":"Docker"},{"location":"testing/containers/#lxc","text":"snap install lxc lxc launch ubuntu-daily:focal test lxc file push whatsthis test/root/whatsthis lxc exec test /root/whatsthis lxc delete --force test","title":"LXC"},{"location":"testing/containers/#podman","text":"snap install podman podman run --detach --tty --name test ubuntu podman cp whatsthis test:/ podman exec -it test /whatsthis podman container rm --force test","title":"Podman"},{"location":"testing/containers/#wsl","text":"","title":"WSL"},{"location":"testing/containers/#enable-wsl","text":"Open a PowerShell console as Administrator and run the following to enable WSL and WSL 2: dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart There is an additional kernel update package required for download here . Once installed, reboot the system to begin using WSL. For more details see these official instructions here .","title":"Enable WSL"},{"location":"testing/containers/#wsl-version","text":"To set WSL 2 as the default version run the following as Administrator in a PowerShell console: wsl --set-default-version 2 It can be helpful to switch between WSL 1 and WSL 2 during testing. Users can list all distributions and change the version of any running distribution by running. wsl --list --all wsl --set-version <distro> [ 2 | 1 ]","title":"WSL Version"},{"location":"testing/containers/#testing","text":"Finally, to test the binary on a WSL distribution, copy it from your local filesystem by accessing it from /mnt/c : cp /mnt/c/Users/<username>/Documents... whatthis ./whatsthis","title":"Testing"},{"location":"testing/hyperv/","text":"Hyper-V Enable Hyper-V Open a PowerShell console as Administrator and run the following and reboot the system: Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All For more details and options see the Install Hyper-V on Windows 10 documentation. Multipass Multipass is a quick way to get an Ubuntu VM up and running. It is available on Windows, MacOS, and Linux. On Windows, if Hyper-V is enabled, it can take advantage of Hyper-V. Once downloaded and installed, a user can launch a VM in PowerShell, transfer a test binary, and test it with: multipass launch focal --name test multipass transfer whatsthis test:/home/ubuntu/whatsthis multipass exec test ./whatsthis multipass delete --force test","title":"Hyper-V"},{"location":"testing/hyperv/#hyper-v","text":"","title":"Hyper-V"},{"location":"testing/hyperv/#enable-hyper-v","text":"Open a PowerShell console as Administrator and run the following and reboot the system: Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All For more details and options see the Install Hyper-V on Windows 10 documentation.","title":"Enable Hyper-V"},{"location":"testing/hyperv/#multipass","text":"Multipass is a quick way to get an Ubuntu VM up and running. It is available on Windows, MacOS, and Linux. On Windows, if Hyper-V is enabled, it can take advantage of Hyper-V. Once downloaded and installed, a user can launch a VM in PowerShell, transfer a test binary, and test it with: multipass launch focal --name test multipass transfer whatsthis test:/home/ubuntu/whatsthis multipass exec test ./whatsthis multipass delete --force test","title":"Multipass"},{"location":"testing/kvm/","text":"KVM The following describes how to launch a KVM system on Ubuntu in order to test the KVM detection. Multipass Multipass is a quick way to get an Ubuntu VM up and running. It is available on Windows, MacOS, and Linux. On Linux, Multipass will launch using QEMU with KVM. To get a Multipass VM on Ubuntu setup to test whatsthis run the following: snap install multipass multipass launch focal --name test multipass transfer whatsthis test:/home/ubuntu/whatsthis multipass exec test ./whatsthis multipass delete --force test CLI These instructions are identical to the QEMU instructions except for the addition of the \"-enable-kvm\" option used during the launch of the VM. First, create some user-data to pass the VM that will setup the 'ubuntu' user with the password of 'password'. Also set your GitHub ID and it will automatically import your SSH key into the VM: export GITHUB_ID = <GITHUB_ID> sudo apt update sudo apt install --yes cloud-image-utils cat > user-data.yaml <<EOF #cloud-config password: password chpasswd: expire: False ssh_pwauth: True ssh_import_id: - gh:$GITHUB_ID EOF cloud-localds seed.img user-data.yaml Get the latest Ubuntu 20.04 LTS (Focal) image and launch the VM: wget https://cloud-images.ubuntu.com/focal/current/focal-server-cloudimg-amd64.img qemu-system-x86_64 -enable-kvm -m 2048 -nographic -snapshot \\ -netdev id = net00,type = user,hostfwd = tcp::2222-:22 \\ -device virtio-net-pci,netdev = net00 \\ -drive if = virtio,format = qcow2,file = focal-server-cloudimg-amd64.img \\ -drive if = virtio,format = raw,file = seed.img Once the system has booted, transfer a local test binary run: rsync -e \"ssh -p 2222\" whatsthis ubuntu@0.0.0.0:/home/ubuntu/whatsthis Then either login with ubuntu and password or SSH to the system using: ssh -o \"StrictHostKeyChecking no\" ubuntu@0.0.0.0 -p 2222 When done to close out of the qemu process using the escape sequence: Ctrl-a c ( qemu ) quit","title":"KVM"},{"location":"testing/kvm/#kvm","text":"The following describes how to launch a KVM system on Ubuntu in order to test the KVM detection.","title":"KVM"},{"location":"testing/kvm/#multipass","text":"Multipass is a quick way to get an Ubuntu VM up and running. It is available on Windows, MacOS, and Linux. On Linux, Multipass will launch using QEMU with KVM. To get a Multipass VM on Ubuntu setup to test whatsthis run the following: snap install multipass multipass launch focal --name test multipass transfer whatsthis test:/home/ubuntu/whatsthis multipass exec test ./whatsthis multipass delete --force test","title":"Multipass"},{"location":"testing/kvm/#cli","text":"These instructions are identical to the QEMU instructions except for the addition of the \"-enable-kvm\" option used during the launch of the VM. First, create some user-data to pass the VM that will setup the 'ubuntu' user with the password of 'password'. Also set your GitHub ID and it will automatically import your SSH key into the VM: export GITHUB_ID = <GITHUB_ID> sudo apt update sudo apt install --yes cloud-image-utils cat > user-data.yaml <<EOF #cloud-config password: password chpasswd: expire: False ssh_pwauth: True ssh_import_id: - gh:$GITHUB_ID EOF cloud-localds seed.img user-data.yaml Get the latest Ubuntu 20.04 LTS (Focal) image and launch the VM: wget https://cloud-images.ubuntu.com/focal/current/focal-server-cloudimg-amd64.img qemu-system-x86_64 -enable-kvm -m 2048 -nographic -snapshot \\ -netdev id = net00,type = user,hostfwd = tcp::2222-:22 \\ -device virtio-net-pci,netdev = net00 \\ -drive if = virtio,format = qcow2,file = focal-server-cloudimg-amd64.img \\ -drive if = virtio,format = raw,file = seed.img Once the system has booted, transfer a local test binary run: rsync -e \"ssh -p 2222\" whatsthis ubuntu@0.0.0.0:/home/ubuntu/whatsthis Then either login with ubuntu and password or SSH to the system using: ssh -o \"StrictHostKeyChecking no\" ubuntu@0.0.0.0 -p 2222 When done to close out of the qemu process using the escape sequence: Ctrl-a c ( qemu ) quit","title":"CLI"},{"location":"testing/qemu/","text":"QEMU The following describes how to launch a QEMU system on Ubuntu in order to test the QEMU detection. These instructions are identical to the KVM CLI instructions except for the absence of the '-enable-kvm' option. First, create some user-data to pass the VM that will setup the 'ubuntu' user with the password of 'password'. Also set your GitHub ID and it will automatically import your SSH key into the VM: export GITHUB_ID = <GITHUB_ID> sudo apt update sudo apt install --yes cloud-image-utils cat > user-data.yaml <<EOF #cloud-config password: password chpasswd: expire: False ssh_pwauth: True ssh_import_id: - gh:$GITHUB_ID EOF cloud-localds seed.img user-data.yaml Get the latest Ubuntu 20.04 LTS (Focal) image and launch the VM: wget https://cloud-images.ubuntu.com/focal/current/focal-server-cloudimg-amd64.img qemu-system-x86_64 -m 2048 -nographic -snapshot \\ -netdev id = net00,type = user,hostfwd = tcp::2222-:22 \\ -device virtio-net-pci,netdev = net00 \\ -drive if = virtio,format = qcow2,file = focal-server-cloudimg-amd64.img \\ -drive if = virtio,format = raw,file = seed.img Once the system has booted, and this will take a considerable amount of time due to the emulation, transfer a local test binary run: rsync -e \"ssh -p 2222\" whatsthis ubuntu@0.0.0.0:/home/ubuntu/whatsthis Then either login with ubuntu and password or SSH to the system using: ssh -o \"StrictHostKeyChecking no\" ubuntu@0.0.0.0 -p 2222 When done to close out of the qemu process using the escape sequence: Ctrl-a c ( qemu ) quit","title":"QEMU"},{"location":"testing/qemu/#qemu","text":"The following describes how to launch a QEMU system on Ubuntu in order to test the QEMU detection. These instructions are identical to the KVM CLI instructions except for the absence of the '-enable-kvm' option. First, create some user-data to pass the VM that will setup the 'ubuntu' user with the password of 'password'. Also set your GitHub ID and it will automatically import your SSH key into the VM: export GITHUB_ID = <GITHUB_ID> sudo apt update sudo apt install --yes cloud-image-utils cat > user-data.yaml <<EOF #cloud-config password: password chpasswd: expire: False ssh_pwauth: True ssh_import_id: - gh:$GITHUB_ID EOF cloud-localds seed.img user-data.yaml Get the latest Ubuntu 20.04 LTS (Focal) image and launch the VM: wget https://cloud-images.ubuntu.com/focal/current/focal-server-cloudimg-amd64.img qemu-system-x86_64 -m 2048 -nographic -snapshot \\ -netdev id = net00,type = user,hostfwd = tcp::2222-:22 \\ -device virtio-net-pci,netdev = net00 \\ -drive if = virtio,format = qcow2,file = focal-server-cloudimg-amd64.img \\ -drive if = virtio,format = raw,file = seed.img Once the system has booted, and this will take a considerable amount of time due to the emulation, transfer a local test binary run: rsync -e \"ssh -p 2222\" whatsthis ubuntu@0.0.0.0:/home/ubuntu/whatsthis Then either login with ubuntu and password or SSH to the system using: ssh -o \"StrictHostKeyChecking no\" ubuntu@0.0.0.0 -p 2222 When done to close out of the qemu process using the escape sequence: Ctrl-a c ( qemu ) quit","title":"QEMU"}]}